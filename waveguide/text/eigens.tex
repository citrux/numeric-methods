\documentclass[a4paper,12pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[sumlimits, intlimits]{amsmath}
\usepackage{amssymb}
\usepackage{tikz, pgfplots}
\usepackage[margin=1.5cm]{geometry}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{indentfirst}
\begin{document}
\section{Дифференциальные и матричные операторы. Собственные значения}
\subsection{Дифференциальный оператор}
	Рассмотрим дифференциальный оператор
	\[
		\frac{\partial^2}{\partial x^2}
	\]
	и определим его собственные значения \( \lambda_k \) и собственные функции
	\( \phi_k(x) \) при дополнительном граничном условии
	\[
		\phi_k(0) = \phi_k(1) = 0.
	\]
	Задача на собственные значения имеет вид:
	\[
		\phi_k'' = \lambda_k\phi_k,\quad
		\phi_k(x) = c_1e^{-ig_k x} + c_2e^{ig_k x},
	\]
	где \( g_k = \sqrt{-\lambda_k} \). Воспользуемся дополнительным граничным
	условием:
	\[
		c_1 + c_2 = c_1e^{-ig_k} + c_2e^{ig_k} = 0,
	\]
	\[
		c_2 = -c_1 = c \Rightarrow \sin g_k = 0 \Rightarrow g_k = k\pi,
		k\in\mathbb{N}.
	\]
	В итоге
	\[
		\lambda_k = -k^2\pi^2,\quad \phi_k = \sin k\pi x,\quad k\in\mathbb{N}.
	\]

\subsection{Матричный оператор}
	Перенесёмся теперь из пространства непрерывных функций в пространство сеточных. Разобьём \( [0,1] \) на \(n\) частей, при этом функция будет определяться своими значениями в \( n+1 \) точках этого отрезка. Таким образом, функция становится вектором \( n+1 \)-мерного пространства.

	Теперь определимся с тем, во что переходит оператор \( \frac{\partial^2}{\partial x^2} \). Нас интересуют только значения этого оператора в узла разбиения, поэтому разложим функцию в соседних узлах в ряд Тейлора и посмотрим, что получится:

	\begin{align*}
		& f(x_{k+1}) = f(x_k) + f'(x_k)h + \frac{f''(x_k)}{2}h^2 + \frac{f^{III}(x_k)}{6}h^3 + o(h^4),\\
		& f(x_{k-1}) = f(x_k) - f'(x_k)h + \frac{f''(x_k)}{2}h^2 - \frac{f^{III}(x_k)}{6}h^3 + o(h^4),\\
	\end{align*}
	откуда
	\[
		f''(x_k) = \frac{f(x_{k-1}) - 2f(x_k)  + f(x_{k+1})}{h^2} + o(h^2).
	\]

	Но вспомним теперь, что мы можем рассматривать функции как векторы, поэтому это же можно переписать в виде
	\[
		f_k'' = D^2_{km}f_m,\quad D^2_{km} = \begin{cases}
			1/h^2, \quad \text{если } |m-k| = 1,\\
			-2/h^2, \quad \text{если } m=k,\\
			0, \quad \text{иначе}.
		\end{cases}
	\]
	Тут возникает естественная проблема с границами, так как не существует \( f_{-1} \) и \( f_{n+1} \). В них вторую производную с точностью \( o(h^2) \) можно выразить иначе:
	\begin{align*}
		& f_0'' = \frac{2f_0 - 5f_1 + 4f_2 - f_3}{2h^2},\\
		& f_n'' = \frac{2f_n - 5f_{n-1} + 4f_{n-2} - f_{n-3}}{2h^2},\\
	\end{align*}

	Оператор в этом случае принимает вид:
	\[
		D^2 = \frac{1}{2h^2}
		\begin{pmatrix}
			2 & -5 &  4 & -1 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			2 & -4 &  2 &  0 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			0 &  2 & -4 &  2 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			0 &  0 &  2 & -4 & 2 & \cdots & 0 & 0 & 0 & 0 \\
			\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\
			0 &  0 &  0 &  0 & 0 & \cdots &  2 & -4 &  2 & 0 \\
			0 &  0 &  0 &  0 & 0 & \cdots &  0 &  2 & -4 & 2 \\
			0 &  0 &  0 &  0 & 0 & \cdots & -1 &  4 & -5 & 2 \\
		\end{pmatrix}
	\]
	
\subsection{Собственные значения и собственные векторы}
	Задача на собственнные значения оператора переходит в задачу на собственные значения матрицы:
	\[
		D^2 f_k = \mu_k f_k.
	\]

	Сразу перейдём к рассмотрению функций, удовлетворяющих граничному условию
	\[
		f_0 = f_n = 0.
	\]
	В этом случае вместо \( n+1 \)-мерного вектора можно перейти к \( n-1 \)-мерному. Оператор при этом примет вид:
	\[
		D^2 = \frac{1}{h^2}
		\begin{pmatrix}
			-2 & 1 &  0 &  0 & \cdots & 0 & 0 & 0\\
			1 & -2 &  1 &  0 & \cdots & 0 & 0 & 0\\
			0 &  1 & -2 &  1 & \cdots & 0 & 0 & 0\\
			\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\
			0 &  0 &  0 &  0 & \cdots &  1 & -2 &  1 \\
			0 &  0 &  0 &  0 & \cdots &  0 &  1 & -2 \\
		\end{pmatrix}
	\]
	Так как мы не рассматриваем \(f_0\) и \(f_n\), то из оператора уходят первая и последняя строки, а учёт их нулевых значений позволяет убрать первый и последний столбцы.

	Зная явный вид оператора можно найти его собственные значения и векторы и сравнить с соответствующими значениями для дифференциального оператора:
	\begin{center}
		\tikz[anchor=center,baseline] \node{
		\begin{tikzpicture}
		\draw (3,6) node{\small $\mu_1 = -9.852449,\quad\lambda_1=-9.869604$};
		\begin{axis}[
			axis x line=center,
			ymajorgrids,
			axis y line=left,
			enlargelimits=0.05]
			\addplot coordinates {
				(0.00,0)
				(0.05,0.049)
				(0.10,0.098)
				(0.15,0.144)
				(0.20,0.186)
				(0.25,0.224)
				(0.30,0.256)
				(0.35,0.282)
				(0.40,0.301)
				(0.45,0.312)
				(0.50,0.316)
				(0.55,0.312)
				(0.60,0.301)
				(0.65,0.282)
				(0.70,0.256)
				(0.75,0.224)
				(0.80,0.186)
				(0.85,0.144)
				(0.90,0.098)
				(0.95,0.049)
				(1.00,0)};
			\addplot[domain=0:1,samples=100,line width=1.5pt]{0.316 * sin(deg(3.14 * x))};
			\end{axis}
		\end{tikzpicture}
		};\hfill
		\tikz[anchor=center,baseline] \node{
		\begin{tikzpicture}
		\draw (3,6.4) node{\small $\mu_2 = -39.154787,\quad\lambda_2=-39.478418$};
		\begin{axis}[
			axis x line=center,
			ymajorgrids,
			axis y line=left,
			enlargelimits=0.05]
			\addplot coordinates {
				(0.00,0)
				(0.05,0.098)
				(0.10,0.186)
				(0.15,0.256)
				(0.20,0.301)
				(0.25,0.316)
				(0.30,0.301)
				(0.35,0.256)
				(0.40,0.186)
				(0.45,0.098)
				(0.50,0.000)
				(0.55,-0.098)
				(0.60,-0.186)
				(0.65,-0.256)
				(0.70,-0.301)
				(0.75,-0.316)
				(0.80,-0.301)
				(0.85,-0.256)
				(0.90,-0.186)
				(0.95,-0.098)
				(1.00,0)};
			\addplot[domain=0:1,samples=100,line width=1.5pt]{0.316 * sin(deg(6.28 * x))};
			\end{axis}
		\end{tikzpicture}};
	\end{center}
	Способ их определения описан в следующих разделах.

	Найдём также оператор для граничного условия вида
	\[
		f_0' = f_n' = 0.
	\]
	Для этого добавим с каждого из краёв по виртуальному узлу: \( f_{-1} \) и \( f_{n+1} \). Тогда из равенства нулю производной на краю через среднюю производную находим
	\[
		f_{-1} = f_{1},\quad f_{n-1} = f_{n+1}.
	\]

	Используя виртуальные узлы, вторую производную на границах можно выразить так
	\[
		f_0'' = \frac{f_{-1} - 2 f_0 + f_1}{h^2} = \frac{-2f_0 + 2 f_1}{h^2}, \quad
		f_n'' = \frac{f_{-1} - 2 f_0 + f_1}{h^2} = \frac{2 f_{n-1}-2f_n}{h^2}.
	\]
	Матрица оператора принимает вид
	\[
		D^2 = \frac{1}{h^2}
		\begin{pmatrix}
			-2 & 2 &  0 &  0 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			1 & -2 &  1 &  0 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			0 &  1 & -2 &  1 & 0 & \cdots & 0 & 0 & 0 & 0 \\
			0 &  0 &  1 & -2 & 1 & \cdots & 0 & 0 & 0 & 0 \\
			\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\
			0 &  0 &  0 &  0 & 0 & \cdots &  1 & -2 &  1 & 0 \\
			0 &  0 &  0 &  0 & 0 & \cdots &  0 &  1 & -2 & 1 \\
			0 &  0 &  0 &  0 & 0 & \cdots &  0 &  0 &  2 & -2 \\
		\end{pmatrix}
	\]

	Теперь перейдём к описанию и реализации алгоритма поиска собственных значений и векторов.

	\subsection{Поиск собственных векторов и значений}

	Итак, у нас имеется некоторая матрица \( A \) и перед нами стоит задача поиска её собственных значений и векторов. Для этого воспользуемся последовательным умножением произвольного вектора \( \vec{x} \) на эту матрицу.

	Идея этого метода состоит в том, что при последовательном умножении вектор будет всё сильнее вытягиваться в сторону собственного вектора с наибольшим собственным значением и вскоре станет почти неотличим от него. Чтобы показать это, разложим вектор \( \vec{x} \) по собственным векторам матрицы \( \{ \vec{v}_i \} \):
	\[
		A\vec{x} = A \sum_i x_i \vec{v}_i = \sum_i x_i A\vec{v}_i.
	\]
	Как вам известно, действие матрицы на собственный вектор сводится к умножению этого вектора на соответствующее ему собственное значение, поэтому
	\[
		A\vec{x} = \sum_i x_i \lambda_i \vec{v}_i.
	\]
	Пусть \( \lambda_1 \) -- наибольшее по абсолютному значению собственное число, тогда
	\[
		A\vec{x} = \lambda_1 \left[x_1 \vec{v}_1 + \sum_{i \neq 1} \frac{\lambda_i}{\lambda_1} x_i \vec{v}_i\right].
	\]
	Домножим полученный вектор на матрицу \(A\) ещё разок:
	\[
		A^2\vec{x} = \lambda_1^2 \left[x_1 \vec{v}_1 + \sum_{i \neq 1} \left(\frac{\lambda_i}{\lambda_1}\right)^2 x_i \vec{v}_i\right].
	\]
	После \( n \) умножений имеем
	\[
		A^n\vec{x} = \lambda_1^n \left[x_1 \vec{v}_1 + \sum_{i \neq 1} \left(\frac{\lambda_i}{\lambda_1}\right)^n x_i \vec{v}_i\right].
	\]
	Так как
	\[
		\left|\frac{\lambda_i}{\lambda_1}\right| < 1,
	\]
	то
	\[
		\left(\frac{\lambda_i}{\lambda_1}\right)^n \to 0,
	\]
	откуда
	\[
		A^n\vec{x} \approx \lambda_1^n x_1 \vec{v}_1.
	\]
	Таким образом, если
	\[
		x_1 = \frac{(\vec{x}, \vec{v}_2,\ldots,\vec{v}_n)}{(\vec{v}_1,\vec{v}_2,\ldots,\vec{v}_n)} \neq 0,
	\]
	то полученный вектор \( A^n\vec{x} \) есть собственный вектор \( \vec{v}_1 \) с точностью до постоянной, а соответствующее ему значение
	\[
		\lambda_1 = \frac{(\vec{v_1}, A\vec{v_1})}{(\vec{v}_1, \vec{v}_1)}.
	\]

	Если требуется найти несколько собственных значений, то следующее по абсолютной величине значение \( \lambda_2 \) можно найти, потребовав
	\[
		x_1 = 0,\quad x_2 = \frac{(\vec{v}_1,\vec{x},\vec{v}_3 \ldots,\vec{v}_n)}{(\vec{v}_1,\vec{v}_2,\vec{v}_3,\ldots,\vec{v}_n)} \neq 0
	\]
	В этом случае первое слагаемое в правой части пропадает и мы имеем
	\[
		A^n\vec{x} = \lambda_2^n \left[x_2 \vec{v}_2 + \sum_{i > 2} \left(\frac{\lambda_i}{\lambda_2}\right)^n x_i \vec{v}_i\right].
	\]
	Далее рассуждения полностью аналогичны.

	\subsection{Программная реализация алгоритма}
	Чтобы программировать такие вещи было приятно, разумно реализовать классы для матриц и векторов с базовыми действиями для них, вроде скалярного произведения векторов и произведения вектора на матрицу.

	Для начала рассмотрим задачу поиска наибольшего по абсолютной величине собственного значения. Так как мы работаем с вычислительной машиной, то при хранении в памяти числа округляются. Следовательно, сделать так, чтобы \( x_1 \) было строго равно нулю в принципе невозможно и в качестве начального приближения можно брать совершенно произвольный вектор, скажем \( (1, 0, 0, \ldots, 0) \).

	Алгоритм поиска может выглядеть следующим образом.
	\begin{algorithm}[h]
	  \begin{algorithmic}
	  	\Function{getMaxEigen}{A}
	    \State $x \gets (1, 0, 0, \ldots, 0)$ \Comment{Затравочный вектор}
	    \State $ \lambda \gets 1 $ \Comment{Значение, чтобы войти в цикл}
	    \State $ \lambda' \gets 0 $ \Comment{Используется для хранения значения с прошлой итерации}
	    \State $ \varepsilon \gets 10^{-6} $ \Comment{Точность по $\lambda$}
	    \While{$|\lambda - \lambda'| > \varepsilon $}
	      \State $x' \gets Ax$
	      \State $\lambda' \gets \lambda$
	      \State $\lambda  \gets x' \cdot x $
	      \State $x \gets x' / \| x' \|  $ \Comment{Нормировка}
	    \EndWhile
	    \State \textbf{return} $(\lambda, x)$\Comment{Собственное значение и нормированный собственный вектор}
	    \EndFunction
	  \end{algorithmic}
	\end{algorithm}

	Рассмотрим теперь вопрос о поиске нескольких собственных значений. Как говорилось выше, для этого нужно, чтобы \( x_1 = 0 \). Если у нас есть некоторый вектор \(x\), то для выполнения этого условия нужно его преобразовать к виду
	\[
		\vec{y} = \vec{x} - x_1\vec{v}_1 = \vec{x} - 
		\frac{(\vec{x}, \vec{v}_2,\ldots,\vec{v}_n)}{(\vec{v}_1,\vec{v}_2,\ldots,\vec{v}_n)}\vec{v}_1.
	\]
	Однако, для этого требуется знать все векторы \( \{ \vec{v}_i \} \), в то время, как мы знаем только \( \vec{v}_1 \).

	Если бы все собственные векторы образовывали ортонормированный базис, то ситуация бы сильно упростилась:
	\[
		\vec{y} = \vec{x} - x_1\vec{v}_1 = \vec{x} - (\vec{x}, \vec{v}_1)\vec{v_1}.
	\]
	В этом случае можно построить простой алгоритм. При этом стоит учесть, что ортогональность системы собственных векторов накладывает ограницение на матрицу:
	\begin{align*}
		& A\vec{v} = \lambda_v\vec{v},\\
		& A\vec{u} = \lambda_u\vec{u},
	\end{align*}
	\[
		(\lambda_v - \lambda_u)(\vec{v}, \vec{u}) = (A\vec{v}, \vec{u}) - (\vec{v}, A\vec{u})
	\]
	Учтём \((\vec{v}, \vec{u}) = 0 \) и распишем покоординатно правую часть:
	\[
		a_{ij} v_j u_i - a_{ij} u_j v_i = (a_{ij} - a_{ji}) v_j u_i = 0,
	\]
	следовательно
	\[
		a_{ij} = a_{ji},
	\]
	то есть матрица должна быть симметричной (в \( \mathbb{C}^n \) она должна быть эрмитовой: \( a_{ij} = a_{ji}^* \)).

	Таким образом, алгоритм для ортогонализации вектора \( \vec{x} \) с уже найденными собственными векторами симметричной матрицы \( A \) можно записать в виде:
	\begin{algorithm}[h]
	  \begin{algorithmic}
	  	\Procedure{orthogonalize}{x, $\{ v_i \}$}
	  	\State $ n \gets |\{ v_i \}| $
	    \For{j = $\overline{1, n}$}
	      \State $x \gets x - (x \cdot v_j)v_j$
	    \EndFor
	    \EndProcedure
	  \end{algorithmic}
	\end{algorithm}

	Используя эту процедуру, можно нескколько усовершенствовать алгоритм поиска максимального собственного значения, чтобы он искал заданное количество отсортированных по убыванию абсолютной величины собственных значений. Для начала, построим алгоритм, производящий поиск максимального собственного значения с собственным ветором, ортогональным заданным векторам.
	\begin{algorithm}[h]
	  \begin{algorithmic}
	  	\Function{getEigen}{A, $\{ v_i \}$}
	    \State $x \gets (1, 0, 0, \ldots, 0)$
	    \State orthogonalize(x, $\{ v_i \}$)
	    \State $ \lambda \gets 1 $
	    \State $ \lambda' \gets 0 $
	    \State $ \varepsilon \gets 10^{-6} $
	    \While{$|\lambda - \lambda'| > \varepsilon $}
	      \State $x' \gets Ax$
	      \State orthogonalize($x'$, $\{ v_i \}$)
	      \State $\lambda' \gets \lambda$
	      \State $\lambda  \gets x' \cdot x $
	      \State $x \gets x' / \| x' \|$
	    \EndWhile
	    \State \textbf{return} $(\lambda, x)$
	    \EndFunction
	  \end{algorithmic}
	\end{algorithm}

	Затем с его помощью можно построить нужный нам алгоритм.
	\begin{algorithm}[h]
	  \begin{algorithmic}
	  	\Function{getEigens}{A, n}
	  	\State vectors $\gets \{\}$
	  	\State eigens $\gets \{\}$
	    \For{j = $\overline{1, n}$}
	      \State $(\lambda, v) \gets $ getEigen(A, vectors)
	      \State eigens $ \gets $ eigens $ \cup  \{ (\lambda, v) \}$
	      \State vectors $ \gets $ vectors $ \cup  \{ v \}$
	    \EndFor
	   	\State \textbf{return} eigens
	    \EndFunction
	  \end{algorithmic}
	\end{algorithm}
\end{document}